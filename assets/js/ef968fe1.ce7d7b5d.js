"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[504],{1277:e=>{e.exports=JSON.parse('{"functions":[{"name":"GetZeroes","desc":"Returns the amount of zeroes in the number\\n\\n```lua\\n\\tprint(InfiniteMath.new(1000):GetZeros()) -- 3\\n```","params":[],"returns":[{"desc":"","lua_type":"number"}],"function_type":"method","source":{"line":377,"path":"src/InfiniteMath/init.lua"}},{"name":"Reverse","desc":"Reverse will attempt to return the constructed number converted into a regular number. If the constructed number is above 1e+308 it will instead return INF.\\n\\n```lua\\n\\tprint(InfiniteMath.new(\\"1, 3\\"):Reverse()) -- 1000\\n```","params":[],"returns":[{"desc":"","lua_type":"number"}],"function_type":"method","source":{"line":394,"path":"src/InfiniteMath/init.lua"}},{"name":"GetSuffix","desc":"Returns a string with the number and a suffix at the end, these suffixes will go up to 1e+12000. After, it will default to returning scientific notation.\\n\\nBy default, it will return an abbreviated suffix (1K). Using true will use the default behavior. Using false will return the full suffix (1 Thousand).\\n\\n```lua\\n\\tprint(InfiniteMath.new(1000):GetSuffix()) -- 1K\\n\\tprint(InfiniteMath.new(1000):GetSuffix(true)) -- 1K\\n\\tprint(InfiniteMath.new(1000):GetSuffix(false)) -- 1 Thousand\\n```","params":[{"name":"abbreviation","desc":"","lua_type":"boolean | nil"}],"returns":[{"desc":"","lua_type":"string"}],"function_type":"method","source":{"line":418,"path":"src/InfiniteMath/init.lua"}},{"name":"ScientificNotation","desc":"","params":[{"name":"abbreviation","desc":"","lua_type":"boolean | nil"},{"name":"abbreviate","desc":"","lua_type":"boolean | nil"}],"returns":[{"desc":"","lua_type":"string"}],"function_type":"method","source":{"line":464,"path":"src/InfiniteMath/init.lua"}}],"properties":[],"types":[],"name":"Number","desc":"An InfiniteMath number that surpasses the limits of -10^308 to 10^308","source":{"line":16,"path":"src/InfiniteMath/init.lua"}}')}}]);